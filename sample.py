# -*- coding: utf-8 -*-
"""Untitled9.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XYuisK9DEZqzV7Z5gQH5xQB46IsHFADj
"""

import ee
import geemap  # optional, for map display

print("Authenticating with Earth Engine...")
try:
    ee.Authenticate()
    ee.Initialize(project='cloudrun-476105')
    print("âœ“ Earth Engine authenticated\n")
except Exception as e:
    print(f"âš  Earth Engine auth issue: {e}")
    print("Make sure you have Earth Engine access enabled\n")

# Define a rectangular ROI in Kerala [min_lon, min_lat, max_lon, max_lat]
# This area is ~5.5km x 5.5km = ~30 sq km
roi = ee.Geometry.Rectangle([
    76.95,  # min Longitude
    9.82,  # min Latitude
    77.10,  # max Longitude
    9.97   # max Latitude
])

# --- Debugging Output ---
# Print the ROI coordinates and calculate its area
print("ROI Defined:")
print(roi.getInfo())
print("--------------------------------------------------")
# Calculate area in square kilometers
area_sq_km = roi.area().divide(1000 * 1000).getInfo()
print(f"ROI Area: {area_sq_km:.2f} sq km")

# Function to mask clouds using the Sentinel-2 SCL (Scene Classification Layer) band
def maskS2clouds(image):
    scl = image.select('SCL')
    # We want to keep pixels that are NOT:
    # 3 (Cloud Shadow), 8 (Cloud Medium Prob), 9 (Cloud High Prob), 10 (Cirrus)
    bad_pixels = scl.eq(3).Or(scl.eq(8)).Or(scl.eq(9)).Or(scl.eq(10))
    # Invert the mask to get good pixels
    good_pixels_mask = bad_pixels.Not()
    return image.updateMask(good_pixels_mask)

# Define the Sentinel-2 SR collection
s2_collection = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED')

# --- Image 1: 2023 ---
# Filter by date, bounds, map the cloud mask, and create a median composite
image_2023 = s2_collection \
    .filterBounds(roi) \
    .filterDate('2023-01-01', '2023-03-31') \
    .sort('CLOUDY_PIXEL_PERCENTAGE') \
    .first() \
    .clip(roi)


# --- Image 2: 2025 (Latest) ---
# We use 2025 to have a 2-year gap for change detection
image_2025 = s2_collection \
    .filterBounds(roi) \
    .filterDate('2025-01-01', '2025-03-31') \
    .sort('CLOUDY_PIXEL_PERCENTAGE') \
    .first() \
    .clip(roi)


# --- Debugging Output ---
print("Image 2023 band names:")
print(image_2023.bandNames().getInfo())
print("--------------------------------------------------")
print("Image 2025 band names:")
print(image_2025.bandNames().getInfo())


# --- Visualization 1: True Color Images ---
# Create a geemap Map object
Map_TrueColor = geemap.Map()
Map_TrueColor.centerObject(roi, 13) # Zoom level 13

# # Define visualization parameters for True Color (Red, Green, Blue)
s2_vis_params = {
    'bands': ['B4', 'B3', 'B2'],
    'min': 0,
    'max': 3000  # Reflectance values are scaled
}


# Add the images and ROI to the map
Map_TrueColor.add_basemap('SATELLITE')

Map_TrueColor.addLayer(image_2023, s2_vis_params, 'Image 2023')
Map_TrueColor.addLayer(image_2025, s2_vis_params, 'Image 2025 (Latest)')
# Create an outline (no fill)
roi_outline = ee.Image().byte().paint(
    featureCollection=roi,  # Geometry or FeatureCollection
    color=1,                # Outline color value
    width=3                 # Outline thickness in pixels
)

# Visualization parameters for the outline
roi_outline_vis = {'palette': ['yellow']}

# Add to map
Map_TrueColor.addLayer(roi_outline, roi_outline_vis, 'ROI Boundary')


Map_TrueColor.addLayerControl()
print("\nDisplaying Map 1: True Color Images")
print("Toggle the layers in the top-right corner to compare 2023 and 2025.")
display(Map_TrueColor)

# Function to calculate and add an NDVI band
# NDVI = (NIR - Red) / (NIR + Red)
# For Sentinel-2: (B8 - B4) / (B8 + B4)
def addNDVI(image):
    ndvi = image.normalizedDifference(['B8', 'B4']).rename('NDVI')
    return image.addBands(ndvi)

# Add NDVI band to both images
image_2023_with_ndvi = addNDVI(image_2023)
image_2025_with_ndvi = addNDVI(image_2025)

# Define the forest threshold
FOREST_THRESHOLD = 0.4

# Create binary (0 or 1) forest masks
# .gt() means "greater than". This creates an image with 1 for forest, 0 for non-forest.
forest_mask_2023 = image_2023_with_ndvi.select('NDVI').gt(FOREST_THRESHOLD)
forest_mask_2025 = image_2025_with_ndvi.select('NDVI').gt(FOREST_THRESHOLD)

# .selfMask() removes all 0-value pixels, so we only see the forest pixels
forest_2023 = forest_mask_2023.selfMask()
forest_2025 = forest_mask_2025.selfMask()

# --- Debugging Output ---
# Let's check the min/max NDVI values in our ROI to see if 0.4 is a good threshold
print("Calculating NDVI range for 2023...")
ndvi_range_2023 = image_2023_with_ndvi.select('NDVI').reduceRegion(
    reducer=ee.Reducer.minMax(),
    geometry=roi,
    scale=10
).getInfo()
print(f"NDVI Range 2023: {ndvi_range_2023['NDVI_min']:.2f} to {ndvi_range_2023['NDVI_max']:.2f}")

print("Calculating NDVI range for 2025...")
ndvi_range_2025 = image_2025_with_ndvi.select('NDVI').reduceRegion(
    reducer=ee.Reducer.minMax(),
    geometry=roi,
    scale=10
).getInfo()
print(f"NDVI Range 2025: {ndvi_range_2025['NDVI_min']:.2f} to {ndvi_range_2025['NDVI_max']:.2f}")


# --- Visualization 2: Classified Forest Areas ---
Map_Forest = geemap.Map()
Map_Forest.centerObject(roi, 13)

# Add the binary forest layers to the map
Map_Forest.addLayer(forest_2023, {'palette': ['006400']}, 'Forest 2023') # Dark Green
Map_Forest.addLayer(forest_2025, {'palette': ['00FF00']}, 'Forest 2025') # Bright Green
# Create an outline (no fill)
roi_outline = ee.Image().byte().paint(
    featureCollection=roi,  # Geometry or FeatureCollection
    color=1,                # Outline color value
    width=3                 # Outline thickness in pixels
)

# Visualization parameters for the outline
roi_outline_vis = {'palette': ['yellow']}

# Add to map
Map_TrueColor.addLayer(roi_outline, roi_outline_vis, 'ROI Boundary')

Map_Forest.addLayerControl()
print("\nDisplaying Map 2: Classified Forest Areas")
print("Toggle the layers to see the classified forest extents.")
display(Map_Forest)

# --- Area Calculation ---

# Get the area of each pixel in square meters
pixel_area = ee.Image.pixelArea()

# Multiply the binary forest mask (1=forest, 0=not) by the pixel area
area_2023_img = forest_mask_2023.multiply(pixel_area)
area_2025_img = forest_mask_2025.multiply(pixel_area)

# Sum the areas over the ROI
# (scale=10 is the native resolution for Sentinel-2 bands used in NDVI)
area_2023_stats = area_2023_img.reduceRegion(
    reducer=ee.Reducer.sum(),
    geometry=roi,
    scale=10,
    maxPixels=1e9
)

area_2025_stats = area_2025_img.reduceRegion(
    reducer=ee.Reducer.sum(),
    geometry=roi,
    scale=10,
    maxPixels=1e9
)

# --- Debugging Output: Final Report ---
# Get the numbers and convert to sq km
area_2023_km2 = ee.Number(area_2023_stats.get('NDVI')).divide(1000 * 1000)
area_2025_km2 = ee.Number(area_2025_stats.get('NDVI')).divide(1000 * 1000)
change_km2 = area_2025_km2.subtract(area_2023_km2)

print("\n--- ðŸŒ³ Forest Cover Change Report ---")
print(f"Total ROI Area: {area_sq_km:.2f} sq km")
print("--------------------------------------------------")
print(f"Forest Area 2023: {area_2023_km2.getInfo():.2f} sq km")
print(f"Forest Area 2025: {area_2025_km2.getInfo():.2f} sq km")
print(f"Net Change: {change_km2.getInfo():.2f} sq km")


# --- Change Highlighting ---

# Find Loss (Forest in 2023 AND Non-forest in 2025)
# (forest_mask_2023.eq(1)) AND (forest_mask_2025.eq(0))
forest_loss = forest_mask_2023.eq(1).And(forest_mask_2025.eq(0)).selfMask()

# Find Gain (Non-forest in 2023 AND Forest in 2025)
# (forest_mask_2023.eq(0)) AND (forest_mask_2025.eq(1))
forest_gain = forest_mask_2023.eq(0).And(forest_mask_2025.eq(1)).selfMask()

# --- Visualization 3: Change Map ---
Map_Change = geemap.Map()
Map_Change.centerObject(roi, 13)

# Add the base image for context (you can toggle it on/off)
Map_Change.addLayer(image_2025, s2_vis_params, 'Image 2025 (Base)')

# Add the change layers
Map_Change.addLayer(forest_loss, {'palette': ['red']}, 'Forest Loss (Deforestation)')
Map_Change.addLayer(forest_gain, {'palette': ['blue']}, 'Forest Gain (Reforestation)')
# Create an outline (no fill)
roi_outline = ee.Image().byte().paint(
    featureCollection=roi,  # Geometry or FeatureCollection
    color=1,                # Outline color value
    width=3                 # Outline thickness in pixels
)

# Visualization parameters for the outline
roi_outline_vis = {'palette': ['yellow']}

# Add to map
Map_TrueColor.addLayer(roi_outline, roi_outline_vis, 'ROI Boundary')

Map_Change.addLayerControl()
print("\nDisplaying Map 3: Forest Cover Change")
print("Red pixels = Forest Loss, Blue pixels = Forest Gain")
display(Map_Change)

